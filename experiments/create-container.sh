#!/bin/bash
set -euo pipefail

# create-container.sh [options] <image-name> [-- cmd...]
# Creates a container instance from a loaded image.
#
# Reads the skeleton config.json from data/images/<image>/bundle/ (squashfs mount,
# read-only) and writes a patched config.json to data/containers/<container-id>/
# with proper security settings:
#   - readonly rootfs
#   - default Docker/Podman capabilities
#   - OCI seccomp profile (from containers/common)
#   - namespaces (pid, mount, ipc, uts, network)
#
# Options:
#   -t            Enable pseudo-TTY (for interactive use)
#   -n <name>     Container ID/name (default: <image>-<random>)
#
# Everything after "--" overrides the image's default command.
# If no command is given, the image's CMD/Entrypoint is used.
#
# Examples:
#   sudo ./create-container.sh alpine_latest
#   sudo ./create-container.sh -t -n myshell alpine_latest -- /bin/sh
#   sudo ./create-container.sh alpine_latest -- echo hello

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
DATA_DIR="$SCRIPT_DIR/data"
IMAGES_DIR="$DATA_DIR/images"
CONTAINERS_DIR="$DATA_DIR/containers"
SECCOMP_SRC="$SCRIPT_DIR/seccomp.json"

# ── Parse options ──
TTY_MODE=false
CONTAINER_ID=""

while getopts ":tn:" opt; do
    case $opt in
        t) TTY_MODE=true ;;
        n) CONTAINER_ID="$OPTARG" ;;
        \?) echo "Unknown option: -$OPTARG" >&2; exit 1 ;;
        :)  echo "Option -$OPTARG requires an argument" >&2; exit 1 ;;
    esac
done
shift $((OPTIND - 1))

if [[ $# -lt 1 ]]; then
    echo "Usage: $0 [options] <image-name> [-- cmd...]"
    echo "  -t          Enable pseudo-TTY (interactive)"
    echo "  -n <name>   Container name (default: auto)"
    echo "  --          Override container command"
    echo "Example: $0 -t -n myshell alpine_latest -- /bin/sh"
    exit 1
fi

IMAGE_NAME="$1"
shift

# Default container ID: image-name + random suffix
[[ -z "$CONTAINER_ID" ]] && CONTAINER_ID="$IMAGE_NAME-$(head -c 4 /dev/urandom | xxd -p)"

# Collect command override (everything after "--")
CMD_ARGS=()
if [[ $# -gt 0 && "$1" == "--" ]]; then
    shift
    CMD_ARGS=("$@")
elif [[ $# -gt 0 ]]; then
    CMD_ARGS=("$@")
fi

# ── Paths ──
IMAGE_DIR="$IMAGES_DIR/$IMAGE_NAME"
IMAGE_BUNDLE="$IMAGE_DIR/bundle"
IMAGE_CONFIG="$IMAGE_BUNDLE/config.json"

CONTAINER_DIR="$CONTAINERS_DIR/$CONTAINER_ID"
CONTAINER_CONFIG="$CONTAINER_DIR/config.json"

if [[ ! -f "$IMAGE_CONFIG" ]]; then
    echo "Error: Image not loaded. No config.json at $IMAGE_CONFIG"
    echo "Run load-image.sh first."
    exit 1
fi

if [[ ! -f "$SECCOMP_SRC" ]]; then
    echo "Error: seccomp.json not found at $SECCOMP_SRC"
    exit 1
fi

# Create container directory
mkdir -p "$CONTAINER_DIR"

echo "==> Creating container '$CONTAINER_ID' from image '$IMAGE_NAME'"
echo "    Image bundle: $IMAGE_BUNDLE"
echo "    Container dir: $CONTAINER_DIR"
echo "==> Patching config.json for crun..."

# ──────────────────────────────────────────────
# 1. Convert containers/common seccomp.json to OCI linux.seccomp format
# ──────────────────────────────────────────────
# The containers/common format has extra fields (archMap, includes, excludes,
# comment, errno) that are not part of OCI runtime spec. We strip them.
echo "==> Converting seccomp profile to OCI format..."

# Map uname -m to SCMP_ARCH_ name
NATIVE_ARCH=""
case "$(uname -m)" in
    x86_64)  NATIVE_ARCH="SCMP_ARCH_X86_64" ;;
    aarch64) NATIVE_ARCH="SCMP_ARCH_AARCH64" ;;
    armv7l)  NATIVE_ARCH="SCMP_ARCH_ARM" ;;
    ppc64le) NATIVE_ARCH="SCMP_ARCH_PPC64LE" ;;
    s390x)   NATIVE_ARCH="SCMP_ARCH_S390X" ;;
    mips64)  NATIVE_ARCH="SCMP_ARCH_MIPS64" ;;
    riscv64) NATIVE_ARCH="SCMP_ARCH_RISCV64" ;;
    *)       echo "Warning: unknown arch $(uname -m), omitting seccomp architectures" ;;
esac

OCI_SECCOMP=$(jq --arg native "$NATIVE_ARCH" '{
    defaultAction: .defaultAction,
    defaultErrnoRet: .defaultErrnoRet,
    architectures: (
        if $native == "" then []
        else [.archMap[] | select(.architecture == $native)] | .[0] |
            [.architecture] + (.subArchitectures // [])
        end
    ),
    syscalls: [.syscalls[] | {
        names: .names,
        action: .action,
        args: (.args // []),
        errnoRet: .errnoRet
    } | if .errnoRet == null then del(.errnoRet) else . end
      | if .args == [] then del(.args) else . end
    ]
}' "$SECCOMP_SRC")

# ──────────────────────────────────────────────
# 2. Define default capabilities (matches Docker/Podman defaults)
# ──────────────────────────────────────────────
DEFAULT_CAPS='[
    "CAP_CHOWN",
    "CAP_DAC_OVERRIDE",
    "CAP_FSETID",
    "CAP_FOWNER",
    "CAP_MKNOD",
    "CAP_NET_RAW",
    "CAP_SETGID",
    "CAP_SETUID",
    "CAP_SETFCAP",
    "CAP_SETPCAP",
    "CAP_NET_BIND_SERVICE",
    "CAP_SYS_CHROOT",
    "CAP_KILL",
    "CAP_AUDIT_WRITE"
]'

# ──────────────────────────────────────────────
# 3. Patch the config.json generated by umoci
# ──────────────────────────────────────────────

# Read the skeleton config from the image (read-only squashfs mount)
CONFIG=$(cat "$IMAGE_CONFIG")

# Point root.path to the image's rootfs (absolute path, since config.json
# will live in a different directory than the bundle)
ROOTFS_PATH="$(realpath "$IMAGE_BUNDLE/rootfs")"
CONFIG=$(echo "$CONFIG" | jq --arg rootfs "$ROOTFS_PATH" '.root.path = $rootfs')

# Override command if specified
if [[ ${#CMD_ARGS[@]} -gt 0 ]]; then
    ARGS_JSON=$(printf '%s\n' "${CMD_ARGS[@]}" | jq -R . | jq -s .)
    CONFIG=$(echo "$CONFIG" | jq --argjson args "$ARGS_JSON" '.process.args = $args')
    echo "==> Command override: ${CMD_ARGS[*]}"
else
    echo "==> Using image default command"
fi

# Apply all patches
TTY_JSON=$(if [[ "$TTY_MODE" == true ]]; then echo "true"; else echo "false"; fi)
CONFIG=$(echo "$CONFIG" | jq \
    --argjson seccomp "$OCI_SECCOMP" \
    --argjson caps "$DEFAULT_CAPS" \
    --argjson tty "$TTY_JSON" \
    '
    # Readonly rootfs
    .root.readonly = true

    # Terminal mode
    | .process.terminal = $tty

    # Set capabilities (all 5 sets)
    | .process.capabilities = {
        bounding: $caps,
        effective: $caps,
        inheritable: $caps,
        permitted: $caps,
        ambient: $caps
    }

    # Set namespaces
    | .linux.namespaces = [
        {"type": "pid"},
        {"type": "ipc"},
        {"type": "uts"},
        {"type": "mount"},
        {"type": "network"}
    ]

    # Set seccomp profile
    | .linux.seccomp = $seccomp

    # Ensure /proc and /dev mounts exist
    | .mounts = (
        (.mounts // [])
        | if any(.[]; .destination == "/proc") then . else
            . + [{"destination": "/proc", "type": "proc", "source": "proc"}]
          end
        | if any(.[]; .destination == "/dev") then . else
            . + [{"destination": "/dev", "type": "tmpfs", "source": "tmpfs", "options": ["nosuid", "strictatime", "mode=755", "size=65536k"]}]
          end
        | if any(.[]; .destination == "/dev/pts") then . else
            . + [{"destination": "/dev/pts", "type": "devpts", "source": "devpts", "options": ["nosuid", "noexec", "newinstance", "ptmxmode=0666", "mode=0620"]}]
          end
        | if any(.[]; .destination == "/dev/shm") then . else
            . + [{"destination": "/dev/shm", "type": "tmpfs", "source": "shm", "options": ["nosuid", "noexec", "nodev", "mode=1777", "size=65536k"]}]
          end
        | if any(.[]; .destination == "/dev/mqueue") then . else
            . + [{"destination": "/dev/mqueue", "type": "mqueue", "source": "mqueue", "options": ["nosuid", "noexec", "nodev"]}]
          end
        | if any(.[]; .destination == "/sys") then . else
            . + [{"destination": "/sys", "type": "sysfs", "source": "sysfs", "options": ["nosuid", "noexec", "nodev", "ro"]}]
          end
    )
    ')

# Write the patched config to the container directory
echo "$CONFIG" | jq . > "$CONTAINER_CONFIG"

# Write a small metadata file for run-container.sh
cat > "$CONTAINER_DIR/tcr-container.json" <<EOF
{
    "containerId": "$CONTAINER_ID",
    "imageName": "$IMAGE_NAME",
    "imageBundlePath": "$(realpath "$IMAGE_BUNDLE")",
    "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF

echo "==> Config written: $CONTAINER_CONFIG"
echo "    terminal: $TTY_MODE"
echo "    command: $(echo "$CONFIG" | jq -c '.process.args')"
echo "    rootfs: $(echo "$CONFIG" | jq -r '.root.path')"
echo "==> Container '$CONTAINER_ID' ready"
echo ""
echo "To run: ./run-container.sh $CONTAINER_ID"
